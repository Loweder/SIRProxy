# Receive data from server
# Arguments
#   1: Address
#   2: Size
function receive_data {
	v_echo "[${a_p["$1"]}] Got data from server: UUID - '$1', Size - $2"
	dd bs="$2" count=1 <&$ln_pi 3>/dev/null >&${a_o["$1"]:-3} 2>/dev/null
}

# Send data to server in format "<address> <size>\n<datagram>"
# Arguments
#   1: Address
#   2: Client PID
#   3: Client read FD
function transmit_data {
	s_data="$(xxd -p -c 0 <"/proc/$2/fd/$3")"
	s_size="$(( ${#s_data} / 2 ))"
	v_echo "[$2] Got data to server: UUID - '$1', Size - $s_size"
	echo "$1 $s_size" >&$ln_po
	echo "$s_data" | xxd -r -p >&$ln_po
}

# Associate an anonymous UUID with the client
# Arguments:
#   1: Old ID
#   2: Client PID
#   3: Create if absent
function client_anonymise {
	declare -n l_addr="$1"
	if [[ "$anonymise" -eq 0 ]]; then
		return
	elif [[ ! -v a_h["$l_addr"] && "$3" -eq 1 ]]; then
		local anon_addr="$2-RANDOM-$RANDOM"
		a_h["$l_addr"]="$anon_addr"
		a_h["$anon_addr"]="$l_addr"
		l_addr="$anon_addr";
	else
		l_addr="${a_h["$l_addr"]:-$l_addr}"
	fi
}

# Attach a client
# Arguments
#   1: Message
#   2: Address
#   3: Client PID
#   4: Client write FD
function client_attach {
	v_echo "[$3] $1 $2"
	a_p["$2"]="$3"
	exec {a_o["$2"]}>"/proc/$3/fd/$4"
	v_echo "[$3] FD is: Client OUT - ${a_o["$2"]}"
}

# Detach a client
# Arguments
#   1: Message
#   2: Address
#   3: Delete anonymisation data
function client_detach {
	v_echo "[${a_p["$2"]}] $1 $2"
	kill "${a_p["$2"]}" 2>/dev/null
	exec {a_o["$2"]}<&-
	unset a_p["$2"]
	unset a_o["$2"]
	if [[ "$3" -ne 0 ]]; then
		local deanon_addr="${a_h["$2"]}"
		unset a_h["$deanon_addr"]
		unset a_h["$2"]
	fi
}

export multicall="${multicall:-SERVER}"

case $multicall in
	SERVER)
		export IFS=" "
		export socket="${TMPDIR:-/tmp}/udp_proxy.$$"
		add_param "server_port" "Port to which the server will connect"
		add_param "client_port" "Port to which the clients will connect"
		add_opt "T" "timeout" "sec" 5 "Set timeout on the connections"
		add_opt "a" "anonymise" 0 "Anonymise clients"
		parse_opts $@

		#Set trap for shutdown
		trap 'exit_kill_server a_p' SIGTERM SIGINT SIGABRT

		#Initiate sockets
		export multicall=CLIENT; #Set type to "CLIENT", for clients to have
		connect_coproc "Listening for server at" "TCP-LISTEN" "$server_port" ",reuseaddr" ln_pi ln_po
		connect_coproc "Internal communication at" "UNIX-RECV" "$socket" "" ln_ii ln_io "-u"
		connect "Listening for clients at" "UDP-RECVFROM" "$client_port" ",reuseaddr,fork" "-t" "$timeout"

		declare -A a_o a_p a_h
		
		while true; do
			#Wait for client commands
			if read -r -u $ln_ii -t 0.1 s_cmd s_pid s_addr ln_si ln_so; then
				case $s_cmd in
					TERM) #Received a command to detach a client
						client_anonymise s_addr "$s_pid" 0
						[[ "${a_p["$s_addr"]}" == "$s_pid" ]] && client_detach "Client timed out at" "$s_addr" 1 ;;
					LINK) #Received a command to attach a client
						client_anonymise s_addr "$s_pid" 1
						[[ -v a_p["$s_addr"] ]] && client_detach "Detaching old client from" "$s_addr" 0
						client_attach "Connecting a client" "$s_addr" "$s_pid" "$ln_si"
						transmit_data "$s_addr" "$s_pid" "$ln_so"
						;;
				esac
			fi

			#Wait for responses
			read -r -u $ln_pi -t 0.1 s_addr s_size
			s_code=$?
			if [[ $s_code -eq 0 ]]; then
				receive_data "$s_addr" "$s_size"
			elif [[ $s_code -eq 1 ]]; then
				v_echo "Server disconnected, exiting"
				exit_kill_server a_p
			fi
		done
		;;
	CLIENT)
		exec {ln_si}<> <(:) #Create input pipe for from-server line
		exec {ln_so}<> <(:) #Create output pipe for to-server line

		#Set trap for shutdown
		trap 'socat STDIN UNIX-SENDTO:$socket <<< "TERM $$ $SOCAT_PEERADDR:$SOCAT_PEERPORT"; exit_kill' SIGTERM SIGINT SIGABRT

		#Notify the master that we're ready to connect, and send initial data
		cat >&$ln_so <&0
		socat STDIN UNIX-SENDTO:$socket <<<"LINK $$ $SOCAT_PEERADDR:$SOCAT_PEERPORT $ln_si $ln_so"
		exec {ln_so}>&-
		
		#Exchange data
		cat <&$ln_si >&1 &
		exit_wait
		;;
esac

